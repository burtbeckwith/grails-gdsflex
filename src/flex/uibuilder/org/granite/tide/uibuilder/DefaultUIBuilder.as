/**
 * Generated by Gas3 v2.0.0 (Granite Data Services).
 *
 * NOTE: this file is only generated if it does not exist. You may safely put
 * your custom code here.
 */

package org.granite.tide.uibuilder {
	
	import flash.net.FileReference;
	import flash.utils.ByteArray;
	import flash.utils.describeType;
	import flash.utils.getQualifiedClassName;
	
	import mx.collections.ArrayCollection;
	import mx.controls.*;
	import mx.controls.dataGridClasses.DataGridColumn;
	import mx.core.ClassFactory;
	import mx.core.IUIComponent;
	import mx.formatters.DateFormatter;
	import mx.formatters.NumberFormatter;
	import mx.utils.ObjectUtil;
	import mx.utils.StringUtil;
	import mx.validators.*;
	
	import org.granite.tide.spring.Context;
	import org.granite.tide.uibuilder.editors.*;
	
	
	[Name("tideUIBuilder")]
    public class DefaultUIBuilder implements IUIBuilder {
    	
    	[In]
    	public var context:Context;
    	
    	public var formatters:Object = new Object();
    	
    	
    	public function buildListColumns(className:String, metadata:Array, labelFunction:Function, simpleOnly:Boolean = false):Array {
			var columns:Array = new Array();
			
			if (!simpleOnly) {
				var column:DataGridColumn = new DataGridColumn("id");
				column.headerText = "Id";
				columns.push(column);
			}
			
			for each (var property:Object in metadata) {
				if (property.display == false)
					continue;
				
				if (property.kind == 'simple') {
					column = new DataGridColumn(property.name);
					column.headerText = property.name.substring(0, 1).toUpperCase() + property.name.substring(1);
					if (property.type == Number) {
						if (property.format) {
							var nfmt:NumberFormatter = new NumberFormatter();
							nfmt.precision = new Number(nfmt);
							formatters[className + "." + property.name] = nfmt;
						}
						column.labelFunction = format;
					}
					if (property.type == Date) {
						if (property.format) {
							var dfmt:DateFormatter = new DateFormatter();
							dfmt.formatString = property.format;
							formatters[className + "." + property.name] = dfmt;
						}
						column.labelFunction = format;
					}
					columns.push(column);
            	}
            	else if (property.kind == 'manyToOne' && !simpleOnly) {
					column = new DataGridColumn(property.name);
					column.headerText = property.name.substring(0, 1).toUpperCase() + property.name.substring(1);
					column.labelFunction = labelFunction;
					var cf:ClassFactory = new ClassFactory(EntityLinkButton);
					cf.properties = { context: context };
					column.itemRenderer = cf;
					columns.push(column);
            	}
			}
			
			return columns;
    	}
    	
    	protected function format(item:Object, column:DataGridColumn):String {
    		if (item == null || item[column.dataField] == null)
    			return "";
    		var className:String = getQualifiedClassName(item);
    		if (formatters[className + "." + column.dataField])
    			return formatters[className + "." + column.dataField].format(item[column.dataField]);
    		return item[column.dataField] as String;
    	}

    	
    	public function buildEditForm(className:String, metadata:Array, form:Object, create:Boolean):Array {
			var properties:Array = new Array();
			
			var desc:XML = describeType(form);
			
			for each (var property:Object in metadata) {
				var info:Object = ObjectUtil.getClassInfo(form);
				var found:Boolean = false;
				for each (var propName:String in info.properties) {
					if (form[propName] is EntityProperty && EntityProperty(form[propName]).property == property.name) {
						properties.push(form[propName]);
						found = true;
						break;
					}
				}
				
				if (!found) {
	            	var componentDescriptor:EntityProperty = buildEditFormItem(property, create);
	            	
	            	if (componentDescriptor)
	            		properties.push(componentDescriptor);
	   			}
			}
			
			return properties;
    	}
    	
    	protected function buildEditFormItem(property:Object, create:Boolean):EntityProperty {
        	var component:Object = null;
        	var editorDataField:String = null;
        	var entityField:String = null;
        	var validator:Validator = null;
        	var percentWidth:int = -1;
        	
        	if (property.inList) {
        		component = new ComboBox();
        		var list:Array = StringUtil.trimArrayElements(property.inList.substring(1, property.inList.length-1), ",").split(",");
        		component.dataProvider = new ArrayCollection(list);
        		editorDataField = "selectedItem";
        	}
        	else if (property.type == Number) {
        		component = new TextInput();
        		editorDataField = "text";
        	}
        	else if (property.type == String) {
        		if (property.widget == 'textArea' || (property.maxSize && property.maxSize > 255)) {
        			component = new TextArea();
        			editorDataField = "text";
        			percentWidth = 100;
        			component.percentWidth = 100;
        			component.height = 100;
        		}
        		else {
        			component = new TextInput();
        			editorDataField = "text";
        			if (property.password == 'true')
        				component.displayAsPassword = true;
        		}
        		if (property.email) {
        			validator = new EmailValidator();
        			if (property.required)
        				validator.required = true;
        			else
        				validator.required = false;
        		}
        		else if (property.minSize > 0 || property.maxSize) {
        			validator = new StringValidator();
        			if (property.required)
        				validator.required = true;
        			StringValidator(validator).minLength = property.minSize;
        			StringValidator(validator).maxLength = property.maxSize;
        		}
        	}
        	else if (property.type == Boolean) {
        		component = new CheckBox();
        		editorDataField = "selected";
        	}
        	else if (property.type == Date) {
        		component = new DateField();
        		editorDataField = "selectedDate";
        	}
        	else if (property.type == FileReference && !create) {
        		if (property.widget == "image") {
        			component = new ImageEditor();
        			component.propertyName = property.name;
        			editorDataField = "fileRef";
        			entityField = "entity";
        		}
        		else {
        			component = new BinaryEditor();
        			component.propertyName = property.name;
        			editorDataField = "fileRef";
        			entityField = "entity";
        		}
        	}
        	else if (property.type == ByteArray && !create) {
        		if (property.widget == "image") {
        			component = new ImageEditor();
        			component.propertyName = property.name;
        			editorDataField = "byteArray";
        			entityField = "entity";
        		}
        		else {
        			component = new BinaryEditor();
        			component.propertyName = property.name;
        			editorDataField = "byteArray";
        			entityField = "entity";
        		}
        	}
        	else if (property.kind == 'manyToOne') {
        		component = new ManyToOneEditor();
        		component.elementClass = property.type;
        		editorDataField = "property";
        		entityField = "entity";
        	}
        	else if (property.kind == 'oneToMany') {
        		component = new OneToManyEditor();
        		component.elementClass = property.type;
        		editorDataField = "collection";
        		entityField = "entity";
    			percentWidth = 100;
        	}
        	else if (property.kind == 'manyToMany') {
        		component = new ManyToManyEditor();
        		component.elementClass = property.type;
        		editorDataField = "collection";
        		entityField = "entity";
    			percentWidth = 100;
        	}
        	
        	if (component == null)
        		return null;
        	
        	var entityProperty:EntityProperty = new EntityProperty();
    		entityProperty.property = property.name; 
    		entityProperty.component = component as IUIComponent;
    		entityProperty.percentWidth = percentWidth;
    		entityProperty.validator = validator
    		entityProperty.editorDataField = editorDataField; 
    		entityProperty.entityField = entityField;
    		entityProperty.bound = false;
    		return entityProperty;
     	}
    }
}